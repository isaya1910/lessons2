2.1 Самый частый случай нарушения SRP это разрастание God Object до тысяч строк кода. Чаще всего такими классами являются контроллеры, которые выполняют огромное количество действий, 
такие ка запросы в базу, маппинг данных, реализация бизнес логики и так далее. А вот если у класса слишком много instance-ов это значит что класс чаще всего является обычным враппером 
для каких то данных, и по своей сути не является классом в классическом его понимании. Также часто бывает что класс отвечает за большое количество функуционала и создается в самых 
разных местах, что и является нарушением SRP.
2.2  Очень часто разработчики создают классы как обертку над одной функцией, что также является не очень хорошим дизайном, 
на мой взгяд для такие вещей отлично подходят миксины или лямбды.

2.3  Как правило это различные приватные функции класса, которые делают какую то обработку данных, дат, арифметические операции и тд. 
Их как правило также можно выносить в отдельным миксины
2.4  В иделае обьекты класса должны быть иммутабельными либо иметь ограниченную видимость мутабельности. Возможность изменять их во множестве приводит к очень многим проблемам.
Самым сложным является отловка багов, очень тяжело дебажить такие классы, так же не стоит забывать о race conditions, когда мы пытаемся изменить обьект из разных потоков.
2.5 Когда класс зависит от деталей реализации других классов, это значит что у нас появляется сильная связность между компонентами. В идеале классы должны зависеть от интерфейсов.
2.6 Downcasting -  признак плохого дизайна, так как по сути мы отказываемся от силы абстракции в угоду реализации. Это признак того что у нас сильная связность между компонентами
Пункт(2.5)
2.7 Мне тяжело было придумать пример и в целом причину данного пункта, я думаю это также как то связано с сильной связностью
2.8 Это значит что родительские классы содержат излишнюю ответственность и функциональность
3.1 Чаще всего это признак того что нарушен Segregation Principle (ISP). То есть интерфейсы слишком большие, и изменения одного требует каскадного изменения классов его реализующих
Либо это также признак сильной связности между компонентами.
3.2 Я называю это Overengineering, когда для решения простой проблемы программисты начинают придумывать сложные решения. Чаще всего это куча слоев абстракции и их имплементаций.
 На мой взгляд самый распростроненным примером является использование Clean Architecture подхода даже там где он не нужен
